计算机基础

        二进制转八进制：
            公式：【三位一取】从低位开始，每三位得到一个八位进制数字
        十六进制转二进制：
            公式:【一转四位】十六进制的一位相当于二进制的四位，计算时十进制转换，不足
        四位高位补0

        二进制转十六进制：
            公式：【四位一取】从低位开始，每四位得到一个十六进制的数字，最后高位不足则
        补0


        十进制	二进制	八进制	十六进制
        0	0	0	0
        1	1	1	1
        2	10	2	2
        3	101


        内存中存储的时数据的二进制形式
        存储数据：
            1、计算机先开辟空间，在存储数据，计算机开辟空间的最小单位时字节。
            2、在数据存储时，用最高标识符号位，0表示正数，1表示复数。

        1 -1

        原码，反码，补码
        原码：规定了字节数，写明了符号位，得到了数据的原码
               0000 0000 0000 0000 0000  0000 0000 0001  ======1bype
        +    1000 0000 0000 0000  0000 0000 0000 0001
        -------------------------------------------------------
               1000 0000 0000 0000  0000 0000 0000 0010  -2
            结论：不以原码形式存储数据

        反码：正数的反码就是其原码，复数的反码就是其原码的符号位不变其他位取反
             0000 0000 0000 0000  0000 0000 0000 0001
        +  1111 1111 1111 1111  1111 1111 1111 1110
        ----------------------------------------------------
            1111 1111 1111 1111 1111 1111 1111 1111
                      结论：不以反码的形式存储数据

        补码：正数的补码是其原码（正数三码合一）
            负数的补码是其反码加1
            0000 0000 0000 0000  0000 0000 0000 0001
        + 1111 1111 1111 1111  1111 1111 1111 1111
        --------------------------------------------------
         1 0000 0000 0000 0000  0000 0000 0000 0001
             加法最后得到的1溢出了，没有存储到内存中

             结论：以补码的形式存储数据

            十进制转二进制: 倒除法（倒着除2），逆序取余数
            二进制转十进制： 当前数值（0,1）依次乘以2的对应位数次幂。从右侧开始表示2的零次方，依次类推

            6  --->

            八进制转二进制：
            二进制转八进制：


            十六进制转二进制：
            二进制转十六进制：


运算符：
        # 运算符： 算术运算符 赋值运算符  关系运算符  逻辑运算符  位运算  三目运算符
        # 1. 算术运算符  + - * /  %  //  **
        # 2. 赋值运算符： =  结合前面的算术运算符使用： +=  -=  *=   /=   %=  //=   **=
        # 3. 关系运算符  >  <  >=  <=  == 是否等于  != 是否不等于
        # 4. 逻辑运算符 and or not    只要使用关系运算符，所有的结果： True False
        # 5. 三目运算符 类似这种的 print("crazyit"), 'a大于b' if a > b else  "a不大于b"

    # 转义字符： 特殊的字符串

        \b	退格符  类似删除键
        \n	换行符
        \r	回车符  每次遇到\r光标都会回到最开始
        \t	制表符  4个空格
        \"	双引号
        \'	单引号
        \\	反斜线



字符串：
		1.# 定义一个字符串,进行索引
		str = 'https://blog.csdn.net/qq_37171353/article/details/77943817'


		str[0] 	调遣字符串中的索引位置的字符
		str[::-1]		字符串进行倒叙
		str.find('/')    查找里面有几个'/'
		str.split('/')	对里面的'/'进行切片
		str.split('/',2) 规定切片的刀数



		2.对字符串的操作指令有：
		
		find() rfind() lfind() repalce() join() split() rsplt() splitlines()  enumerate()找字符串的位置

		upper() lower() 转换为大小写

		trip() ltrip() rtrip() 用于去除文本中的空格

		center()  ljust() rjust() 

		encode() 转换字符集
		
		3.判断：
		isdigit() isalpha() isupper() islower()  数字/字母/大写/小写



		4.格式化字符串：

		format()
			'{},{},{}'.format(value,value,value)

			'{name},{name},'.format(name="tom")

			'{:s},{name}'format(name='tom')

			{:s} {:d}  {:.2f}.format('',19,56.8)

	切片：
		split()
		replce()

	用于判断文件传输；
		endswith()
		startswith()


列表(list)：
	
	指令操作符：

	1.添加字符
		append()  extend() insert()

	2.删除字符
		pop() remove() clear()    

    3.清除list所占内存
    	del list

    4.对列表中的整体数据进行操作
    	排序sort() --->  reverse=True 翻转  统计个数count()  sorted()

    	sum() avg() min() max()

    5.列表进行添加/删除元素时，循环体中下标的变动会使结果出现跳号





元祖(tuple)：
	
	元祖可以进行 加/减/乘法的操作，并且应该注意元祖中的数据只能进行读取（可以惊醒强制转换—————list(tuple)


	回顾；

		列表：容器


		元祖：容器

							列表  				容器


		类的关键字：      	list
		创建：     list=[ ]  list1 = [1,2,3,4]  tuple=(1,3,5,6,9)
		获取：	  list1[下标]    下标：0~len(list1)-1  tuple[index]  index:)~len(tuple1)
		切片：
		符号：
		判断in；
		系统函数：   	sum max min sorted len   sum max min sore
		转换：  	  list(变量) 变量：tuple ,str    tuple()
					变量为字符串：将字符产拆开放入列表
		函数： 添加三种：删除四种，其它：index sort   函数：index(e) ---->下标位置
					reverse


集合：

		关键字：set					可以用来去除重复项
		引入：无序 不重复
		列表和元祖：支持下标

		1.创建

		set1 = set()

		list1 = []

		2.无序：
		保存的顺序和输出的顺序不是一致的，所以没有下标
		list:链表实现
		set: hash表实现
		3.增删改查
		iterable:  list tuple str set

		添加：add()  update(iterbale)  一组添加
		删除:pop() pop() remove(e)  del   discar类似remove


字典；

	dict:底层也是hash表
		# 	关键字：dict()
		# 	定义{}

		# 	图书管理：

		# database = [[],[],[],[]]


		# 1.字典的创建

		# 不同list tuple set ------>添加元素：单独的元素

		# list.append(90)

		# 字典：{key:value,key:value}

		# 特点：  key不能重复  value允许重复

		# 如果key值重复默认后面的将前面的覆盖

		# 总结：key就是唯一标识，比如学号，工号，身份证号  用户名（不允许重复）


		增删改查

		1.添加

		dict ['001'] = 'xingdong'

		2.修改
		如果字典中存在这个key，则会发生值的修改，判断值替换旧的值
		dict1[key] = value

		3.删除      查询get（）
		pop(key)  表示根据key删除键值对

		popitem()  表示随机删除任意一对(实际删除最后一个【字典也是根据哈希值保存，因此是随机】)

		clear()

		del   清除字典内存   或者在后面加key值（删除key所在位置）

		# for index,value in enumerate(list1): # [(0,'a'),(1,'b'),(2,'c')]
		# 	print(index,value)

可变与不可变：
		可变： 内存地址没有发生改变，但是里面内容可以变化
		不可变： 只要值有变化则内存地址就变啦

		不可变的类型： int  str  tuple  float  bool

		可变的类型:  list  set  dict




可迭代的：
		type()   获取
		isinstance()  判断

		可迭代的类型: list  tuple  set  dict  str

		总结： 所有可迭代的可以与for..in

		a =10     #下列代码可以判断是否可以迭代

		print(isinstance(a,int))
		print(isinstance(a,str))






函数：  执行某个特定任务的一段代码。通过def关键字将此代码封装起来。  封装起来的整体称作'函数'。

		作用：  减少代码的重复，提高代码的可读性

         #函数也可以作为参数存在
                    def test():
                        print('------>test')


                    def test1():
                        print('----->test1')


                    # 函数也可以作为参数存在的
                    def func(f):
                        f()
                        test1()


                    func(test)
		 步骤：
		 1. 定义函数def
		 	变量注意分布



		 2. 调用函数：函数名()


		 1. 函数定义则会开辟内存空间  ---> 对象


		#   无参数的函数

		#   有参数的函数：
		# 	参数的类型和参数的个数 都是没有要求，

		# 	注意：定义的参数的个数  与调用时的参数个数要一致


        L （Local） 局部作用域
        E （Enclosing） 闭包函数外的函数中
        G （Global） 全局作用域
        B （Built-in） 内建作用域


        全局的变量是每个函数都可以访问的，但是如果想修改全局变量则需要添加global声明
        注意： 如果全局变量是不可变的(int str tuple xfloat),在函数中发生修改则需要添加global
        但是如果是可变的（list  set  dict） 可以不添加global


高阶函数：
        匿名函数：lambda x,y:x+y 这样的简单语句叫匿名函数
        系统中，有些函数可以将函数作为参数使用，这些函数就是高阶函数。

        filter(function,iterable)   ---->  function通常函数是一个匿名函数，而且该函数返回值是True或者False

        sorted(iterable,key=function[,reverse=True]) ----> 根据key指定的条件进行排序，其中key的值是一个函数（匿名函数）

        map(function,*iterables) ----->映射， 给一个可迭代对象返回一个新的可迭代的（依赖函数function产生）


        from functools import reduce
        reduce(function,sequence,[initial]) ---> function: 必须两个参数，  sequence: 序列  （list，元组，set）

         作用就是对序列中的元素进行迭代运算
         如果存在initial，首先会作为x位置的值出现。

         reduce（lambda x,y:x+y,(1,2),10）
         x  y
         10+1  ---> 11   2
                     x    y
                           ----> 13
                                  x
         value = 13




闭包：
         在一个外层函数中定义了一个内部函数，内部函数使用了外部函数的临时变量，并且外部函数的返回值是内部函数。
         这个结构就是闭包

         重点：
           1. 嵌套
           2. 内部使用了外部变量
           3. 返回的是内部函数

        说法： 如果一个函数调用结束，则里面的所有的变量或者函数占用的内存都会释放。


        def number():  # 外部函数
            number = 10 # 外部变量
            def inner():  # 内部函数
                sum +=number  # 调用外部变量
                print(sum)
            return inner   # 外部变量返回内部变量

        r = outer()

        函数可以作为参数存在于函数中

        一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。
        但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，
        就把这个临时变量绑定给了内部函数，然后自己再结束。

装饰器：包装

        原来有一个函数，函数的功能是有限的，但是要求：不改变原函数的情况下，使函数功能变得更加强大
        被装饰函数有参数（多个）

        装饰器如何可以装饰多个函数
        格式：
        def decorator(func):
            def wrapper(*args,**kwargs):
                ...
                ...
                func(*args,**kwargs)
                ...
            return wrapper



        装饰器：包装  开放（原函数功能可以更强）封闭（不能改变原函数）

        原来有一个函数，函数的功能是有限的，但是要求：不改变原来的函数的情况下，能够使用函数变的功能更强。

        装饰器的使用步骤：
        1.定义装饰器
           闭包+参数 ：是一个 函数
        2.使用：
            @装饰器名字
            def 被装饰函数（）

        3.函数调用；A()
        补冲：
        @装饰器名字
        只要函数上方存在’@装饰器名字‘在执行的时候底层：
        1.被装饰函数作为参数传给装饰器
        2.执行装饰器
        3.将装饰器函数的返回值赋值给被装饰器

生成器：

        产生生成器：
        1.列表生成器 g = (i for i in range(1000))
        2.函数+yield   生成器
          yield 关键字  ~ return i + 暂停
          下一次再调用的时候就从暂停的位置向下执行

        如果想获取生成器的值：
        1.next(g生成器对象） ---》产生一个元素

        如果使用next()获取生成器对象元素，如果没有元素了，再调用next则会博爱错
        stoplteration

        2.借助于生成器自身方法
           list  str
+
          生成器对象__next__()

        3.send(值) ~类型  生成器对象 __next__()  +传值
           注意：
               第一次传值必须是空的，如果不传None 将报错

                    list1 = [2, 3, 4, 13, 4, 5, 6, 7]
                    g = (x for x in list1 if x % 2 != 0)

                    print(next(g))
                    print(next(g))
                    print(next(g))

                    print(g.__next__())


                    # 个生成器传值

                    def func():
                        for i in range(5):
                            e = yield i
                            e += i
                            print('hello', e)


                    g = func()
                    print(g)
                    g.send(None)
                    g.send(9)
                    g.send(2)



        回顾
        递归函数：
        定义一个函数，函数的内部调用了自身函数。

        1.关键要有出口
        2.逐渐要向出口靠近

        斐波那契数列


        生成器：
            x for x in list if x%2=0
          可以用next()调用
          输入第一个
          yield
          send() 向里面发送参数

        迭代器：iterator01.py
            迭代器，   可迭代的，  生成器
            iterator iterable generator

        可迭代的未必一定是迭代器（list,set,tuple,dict,str可迭代但不是迭代器)
        但是生成器是可迭代的也是迭代器

        可以通过系统函数next（）调用的就是迭代器

        # 判断是不是迭代器和迭代对象

        from collections import Iterable, Iterator

        list1 =[1,23,4,5,5,6]
        print(isinstance(list1,Iterable))
        print(isinstance(list1,Iterator))

面向对象：
类： 属性  方法
        对象
        对象访问属性和方法：


        类的属性：
            类属性
            对象属性


        类属性的修改，类名.属性名 = 新值
        对象的属性：对象名.属性名 = 新值   （对象中有没有这个属性，如果有相当于
        更新值，没有相当于添加一个新的属性）

        属性的搜索顺序：对象名：属性
        1.先找对象本身，如果有则获取自身的属性
        2.没有属性，则去类中获取，有则取出
        3.没有则报错


        对象属性：
            对象本身里面的属性，称作对象属性

        使用__int__实现对象的统一（使对象的属性统一）
        作用：
        1.创建对象的必经之路__int__
        2.同过__int__达到所有对象的统一
        3.__int__函数的self是指当前对象（对象本身）

        在对象的调用上应该注意：
        属性就用赋值式，调用方法就因该对象名.方法名()


静态方法：
        对象方法，静态方法，类方法三者的区别：

            对象方法：依赖对象，self关键字相关
                所有的对象方法参数是必须有self参数
                对象方法只能通过对象调用

            类方法：
                依赖类 cls本身
                定义要使用classmethod，该方法必须有参数cls
                类方法中只能使用类属性和类方法
                类方法可以通过类和对象访问

            静态方法：依赖类 类似类方法
                定义要使用装饰器staticmethod，改方法是不需要参数（cls,self)
                静态方法中可以通过类名，属性名，类名，方法名  反问类属性 和类方法
                静态方法可以通过类和对象调用


        类方法：@clssmethod
            类似 类属性
            只不过定义方式：
                @classmethod
                def 方法名（cls):
                    pass
                 类方法特点：
         1.类方法中无法访问对象属性和方法
             2.必须使用classmethod装饰器定义
             3.类方法的参数式：cls 贷表的式类对象 类本身person
             4.访问方法：类名.类方法  对象.类方法名（）
             优先查找对象方法，如果对象方法中不存在则查找类方法
             对象可以调用类方法，但是类方法中只能访问类属性和类方法



        静态方法：@staticmethod
            def 静态方法（）：
                pass
            特点：
            1.使用@staticmethod装饰
            2.静态方法，方法没有必须的cls,self参数
            3.静态方法里面只能访问类属性和类方法
            补充：
                如果想要访问对象的内容，可以通过参数传递一个对象到方法中。

         魔术方法：
             魔术方法就是一个类的特殊方法，和普通方法唯一的不同时，普通方法需要调用！而魔术方法由系统自动调用。(有很多可以查看文档使用)
              __名__()

              __init__() : 魔术方法之一

              __new__():
              所有类的super默认都是object
              实例化魔术方法  类方法
            触发时机： 在实例化对象时触发
            参数：至少一个cls 接收当前类
            返回值：必须返回一个对象实例
            作用：实例化对象
            注意：实例化对象是Object类底层实现，其他类继承了Object的__new__才能够实现实例化对象。
            没事别碰这个魔术方法，先触发__new__才会触发__init__

        __del__():析构函数   垃圾会收，释放调用对象的空间
            p1 = Person()
            print(p1)
            del p1 -->删除对象      所有的程序结束后都会默认启动垃圾回收机制

        __call__

        __str__
            打印对象就可以打印出相应结果
        __repr__
            print(repr(r)) 才能打印
        当两个对象需要进行比较的时候出发对应的函数

        __lt__   <

        __gt__   >

        __le__   <=

        __ge__   >=

        __eq__   ==
面对对象
    封装：
        1.属性和方法封装到类中
        2.将属性私有化，定义公有的set和get方法设置或者访问值
        **私有化：属性或者方法只能在类体中被访问
        之所以私有化外界访问不到是因为，解释器在底层给__属性偷偷改名了格式
        get() set() 方法获取私有化对象

        系统提供了一个装饰器：property
        步骤：
        1.私有话属性
        2.先定义get部分
        @property
        def age(self):
            return self.__age

        只要有以上内容就可以通过对象访问：person.age
        3.完成set部分：
            @age.setter
            def age (self,age):
                pass
             *******************************************
                            @property
                            def age(self):
                                return self.__age

                            @age.setter
                            def age(self, age):
                                self.__age = age
             *******************************************
                 只要有以上内容则：可以赋值 person.age = 30
        总结：
            1.私有化：__属性名  双下划线 只能在类中访问
            2.公有化：属性名
            3.受保护的：_属性名 在类体中，对象，子类可以访问



    继承：
        class Person： 父类father class  超类 super class  基类 base class

        子类只能继承父类公有的属性和方法，受保护属性和方法也是可以继承


    重写 override
          父类的属性或者方法不能满足子类需求，子类中定义了一个跟父类的方法或者属性同名的
          这种情况下就会发生重写（覆盖）

          如果子类的方法中需要调用父类的方法，
          方式：
          1. 父类名.方法名（self）
          2. super(子类名,self).方法名()


        python多继承的搜索顺序:
            深度优先
            广度优先
         ***通过打印  Child.__mro__可以得到类的先后顺序


        python3
            新式类： 多继承的搜索顺序都是：深度优先

    多态：
        has a 关系:
         class Student:
             def borrow_book(self,book):
                pass

          student has a book

          一个对象可以作为参数传给另一个对象
          book对象作为参数传给Student对象
        is  a  继承
        '''

        java： 面向对象特点： 封装，继承，多态
        python  面向对象的特点是： 封装，继承
        多态：弱类型  假多态
        issubclass(Cat,Animal):  第一个参数是子类，第二个参数是父类
        返回值就是Cat是否是Animal的子类  True  False
                if issubclass(Cat,Animal):
                    print('yes')
                else:
                    print('no')

模块
        模块：Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 语句，函数，类，对象。
        包： 其实就是一个文件夹，存放多个模块
        导入模块的方式：
        1. import 模块名
        2. from 模块名 import 函数，类，变量
           from 模块名 import *   ----> 代表的是该模块中所有内容
        '''
        # 通过import关键字导入模块
        # import test
        #
        # # 如何使用test模块中的功能?  模块名.函数()   模块名.类
        # test.find_min()

         知识回顾：
                    面向对象：
                    方法：
                    对象方法：
                    定义在类中，方法的参数必须有一个self，self对象本身。

                    类方法
                    定义在类中，使用装饰器@classmethod装饰的方法，必须有参数cls（表示的是类本身），称作类方法
                    类方法中可以访问类属性，类方法（cls.属性..），但是无法访问对象的属性和方法

                    静态方法---->在参数里必须添加两个参数，调用时相同否则报错

                    定义在类中，使用的装饰器是@staticmethod装饰方法,没有类似self，cls这类参数，称作静态方法
                    静态方法可以访问类属性，类方法，要通过类名.属性名..

                    魔术方法：
                    系统定义的，无需自己调用，在某种场景下会默认触发的方法。 称作魔术方法。

                    __init__ : 初始化属性赋值对象
                    __new__ : 创建实例化对象的
                    __str__ : 将对象打印的时候，能够以字符串的形式表示
                    类似：__repr__  返回值都是字符串
                    __call__: 触发条件就是把对象当成一个函数名使用的时候
                    __del__: 对象回收的时候触发

                    对象比较的时候：
                    __lt__:
                    __gt__:
                    __le__:
                    __ge__:
                    __eq__:

                    面向对象： 封装，继承，多态
                    封装： 私有化属性，并且定义公有的set和get方法
                    私有化属性：访问范围： 类体本身
                    self.__名字
                    对象名.__名   ---》无法直接访问  ，底层偷偷改名了  _类名__属性名

                    set：设置值
                    def setAge(self,age):
                        添加各种验证

                    get: 取值
                    def getAge(self):
                        return self.__age


                    person.setAge(20)
                    person.getAge()

                    装饰器：@property
                    步骤：
                    1.先定义get
                    @property
                    def 属性(self):
                        return self.__age
                    2. 设置值
                    @属性.setter
                    def 属性(self,值)：
                        添加各种验证
                    3. 创建对象

                    person.age
                    person.age=20

                    通过打印  Child.__mro__(对象.__mro__)可以得到类的先后顺序

模块：

        * 针对：
        1,__all__限制__init__.py 文件中对外访问内容限制
            在[]列表中的是对外界可以访问的，不再列表的就是不可以访问的。
        2.__all__里面还可以添加模块名。
            目的：如果在一个模块中，from包名 import *
            外界想要访问模块，模块名.函数（） ————————》必须在__all__=[添加的模块名....]

        __init__.py的作用
            把某一个目录（文件夹）变成一个包
            使得其他模块使用包.包名的某一块模块/函数/变量/类 这种方法时可用
            import包
            from 包名。模块 import 函数
            from 包名 import * + __all__

        __init__.py是么时候有用
            如果某一个目录在后期导入使用时知识作为中间目录衔接使用，则可以不加__init__
            如果某个目录后期会直接或间接心事地作为一个包导入使用，那么必须必须必须

        import sys #print(sys.path) 打印搜索路径

        那些东西可以直接被import
            模块文件（。py）
            c或c++扩展（以编译为共享库或ddl文件）
            目录/包（包含多个模块，不一定要有————init————）import 包名
            内建模块（使用c编写并已连接到python解释器中）





模块回顾：

        模块： 一个py文件——————》模块

        模块之间的相互使用：

        模块导入：
        1.import 模块名
        2.from 模块名 import 函数、类、变量
          from 模块名 import *
                限制*使用的内容__all__= [可以通过*访问的内容]

        包：模块的组织方式
            文件夹+__init__.py ---》包

            存放多个模块

        包中模块之间的相互使用：
        导入方式：
        1.import  包名.模块名.函数名（）
        2.from 包名。模块名  import 函数名|类|变量
          from 包名.模块名   import * --》导入该模块中所有的内容
                                     --> __all__ 限制
          from 包名 import * ———》导入包中的所有的内容（模块+__init__.py中的内容）
                            ————> 限制：在__init__.py文件中限制__all__=[]

        __init__.py 作用：
            1.只要包导入，只会执行一次
            2.魔术模块---》只要包导入的时候就默认会执行该模块的内容
            3.该模块中的内容就可以作为一些初始化内容存在
            4.将文件夹变成文件里的包+ __init__.py   ————》包
        导入时所搜的顺序：sys.path

        导入执行：
        from 包名.模块名 import xxxxx

        顺序：
            1.先找包中的__init__.py并执行此文件
            2.再去找模块，并执行模块
                补充：__name__的作用：
                     __name__在本模块中叫：__main__
                             在其他模块导入：包名.模块名
        避免循环使用：

        原因：
        A模块使用B中的内容，B模块有使用A中内容
        解决：
            1.将代码重构
            2.将导入放入函数中
            3.将导入放到最后

异常：
        异常即是一个事件，该时间在程序执行过程中发生，影响了程序的正常执行
        一般情况下，在python无法正常处理程序时就会发生。


        错误：
        异常时python对象，表示一个错误


        异常处理
        1.try ...except

            格式：
            try：
                可能发生异常的代码
            except：
                只有异常才会执行的代码块

        2.try... except...except... 后面跟多个except
            except错误后应添加相应的错误类型
            exception Value as err： 后面打印err错误类型

        3.try... except...else...（异常处理的时候才会报else）
        多个异常处理时将Excepion最大的方最后（默认先后顺序找错误的）
                except:
                    pass
                else:
                    print()

        4.try... except...finally...
            使用场景：无论有没有异常都会执行的代码
                文件操作    打开文件    finally 往往释放文件的链接
                数据操作    数据库连接

         ## 在else 与 finally 同时加return值 在末尾的可以覆盖之前的

        -避免循环导入：
        ****if __name__==’__main__‘:
                func()

各种模块
        math 数学模块

        random 随机数模块

        time 和 sys 模块

        datetime： 日期时间模
        类：
        datetime 重点  now（）
        date  重点: today()
        time  了解
        timedelta 重点  设置时间差  + -

        hashlib
        md5算法：单向
        str————》md5加密  十六进制  是32位

        sha1 算法  十六进制 是40位

        sha256 算法: 单向  十六进制是64位

        浅层和深层copy
         拷贝：
         深拷贝
         浅拷贝

         python中对象三要素：
         id （地址） type（类型）  value（值）

        浅层和深层copy


        logging:日志模块

文件的操作：

        os模块
        函数：
        os.getcwd()  获取当前文件所在的目录，以绝对路径方式返回
        os.mkdir() # 新建文件夹  如果文件存在则报错FileExistsError
        os.rmdir() 删除空白的文件夹directory
        os.listdir() 列出所有的文件到列表中
        os.remove()  删除文件file
        os.chdir(路径)  切换目录  类似cd 路径


        os.path模块：

        os.path.exists()  判断文件或者目录是否存在
        os.path.join()  路径的连接
        os.path.dirname(__file__) 获取当前文件所在的文件夹
        os.path.isdir()  是否是文件夹
        os.path.isfile()  是否是文件
        os.path.split(path) 分割的是文件夹与文件名
        os.path.splitext(path) 分割的是:（文件夹/文件名，扩展名）


        文件操作：
        日志，文件的上传，文件的下载
        使用者  ---   服务器
        文件：
        文本文件: a1.txt   a1.doc (非纯文本文件)
        字节类型: 图片  音乐  电影
        read  --->r
        readline()   ----> 每次读取一行
        read()  ----> 将所有的内容读取到buffer，再讲读到的所有内容一次性输出

        write --->w
        写操作：
        每次执行的时候都会，清空原有内容，写入当前的内容
        append --->a
        追加操作：
        每次执行的时候，光标每次停留在文件的最后，写入的时候从光标位置开始

        open(filename,mode,buffer,encoding) ： 打开一个文件，需要指定文件打开的格式（mode = r,w,x,a,b,+）
        返回值是一个流stream


        文件操作：参照点：pycharm
        read  输入
        write 输出

        with open('1.txt',mode='a') as rscram:
            w = rscram.read()

        作用：
        1.保存数据。持久化保存
        2。文件的上传与下载

        open(filename,mode,buffer,encoding)   通过open跟文件打交道,返回值：流对象

        通过流对象调用方法：
        读：
            read()
            readline()  每次读取一行内容
        写：

        绝对路径；   G:\=====宋老师讲课内容======\python1906\feiq\Recv Files\pythonday13\代码\day13_面向对象
        相对路径：完整的磁盘访问路径
        raw：原有的

        open('a1.txt')  ------>读取的文件找不到会报错filenotfounderror
        open(r'file\a1.txt')  ------->同级别的
        open(r'...\...\a1.txt')

        文件操作：
        日志，文件的上传，文件的下载
        使用者  ---   服务器
        文件：
        文本文件: a1.txt   a1.doc (非纯文本文件)
        字节类型: 图片  音乐  电影
        read  --->r
        readline()   ----> 每次读取一行
        read()  ----> 将所有的内容读取到buffer，再讲读到的所有内容一次性输出

        write --->w
        写操作：
        每次执行的时候都会，清空原有内容，写入当前的内容
        append --->a
        追加操作：
        每次执行的时候，光标每次停留在文件的最后，写入的时候从光标位置开始

        open(filename,mode,buffer,encoding) ： 打开一个文件，需要指定文件打开的格式（mode = r,w,x,a,b,+）
        返回值是一个流stream

序列化与反序列化

文件操作：参照点：pycharm
read   输入
write  输出

作用：
1. 保存数据, 持久化保存  日志
2. 文件上传与下载

open(filename,mode)  通过函数跟文件打交道,返回值：流对象

通过流对象调用方法:
 读：
    readline()  每次读取一行内容
    read()

 写:
    write()


# 相对路径: open('a1.txt')  表示跟file02.py同目录的a1.txt
# 绝对路径: 完整的磁盘访问路径  C:\Users\running\Desktop\pythonday17\代码\day17文件与正则\a1.txt
# raw:  原有的  不对\进行转义




